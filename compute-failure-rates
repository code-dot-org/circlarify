#!/usr/bin/env ruby
# A script to analyze a range of CircleCI builds for known failures.
# For available options, run ./search-circle-builds -h

require 'active_support/time'
require 'launchy'
require 'optparse'
require_relative './lib/project'
require_relative './lib/circle_project'

project = Circlarify::Project.new

class Hash
  # Like Enumerable::map but returns a Hash instead of an Array
  def hmap(&block)
    Hash[map {|k, v| yield k, v }]
  end
end

OUTPUT_DIRECTORY = File.expand_path('~/.circle-cli/output').freeze

options = {
  output_format: 'human-readable',
  custom_columns: []
}
OptionParser.new do |opts|
  opts.banner = 'Usage: ./compute-failure-rates [options]'

  opts.separator <<-EXAMPLES

  Examples:

    Default behavior, view stats for the last 30 builds:
    ./compute-failure-rates

    View stats for 30 builds ending at build 123:
    ./compute-failure-rates --end 123

    View stats for all builds since (and including) build 123:
    ./compute-failure-rates --start 123

    View stats for builds in range 123-456 inclusive:
    ./compute-failure-rates --start 123 --end 456

  Options:
  EXAMPLES

  opts.on('--start StartBuildNumber', String, 'Start searching at build #. Default: Get 30 builds.') do |n|
    options[:start_build] = n.to_i
  end
  opts.on('--end EndBuildNumber', String, 'End searching at build #. Default: Latest build.') do |n|
    options[:end_build] = n.to_i
  end
  opts.on('--group branchName,branchName', Array, 'Add a column aggregating results for the listed branches.') do |a|
    options[:custom_columns] << a
  end
  opts.on('--branch branchName', String, 'ONLY show results for the given branch.') do |b|
    options[:branch] = b
  end
  opts.on('--csv', 'Display results in CSV format.') do
    options[:output_format] = 'csv'
  end
  opts.on('--plot', 'Display results as a graph') do
    options[:output_format] = :plot
  end

  project.provide_cli_options opts
end.parse!

begin
  @project = CircleProject.new(project.repository)
rescue ArgumentError => e
  puts e.message
  exit(-1)
end

# Download and format the build information we need
build_range = @project.build_range_from_options(options)
build_infos = @project.get_builds(build_range).map do |build|
  next if build['queued_at'].nil? || build['branch'].nil? || build['outcome'].nil?
  {
    build_num: build['build_num'],
    queued_at: DateTime.parse(build['queued_at']),
    branch: build['branch'],
    # Possible build outcomes: :canceled, :infrastructure_fail, :timedout, :failed, :no_tests or :success
    succeeded: build['outcome'] == 'success',
    failed: build['outcome'] == 'failed' || build['outcome'] == 'timedout'
  }
end

# Group the builds by date
builds_by_date = build_infos.compact.group_by do |build_info|
  build_info[:queued_at].to_time.in_time_zone('Pacific Time (US & Canada)').strftime('%Y-%m-%d')
end

# Define columns - each maps to a lambda that filters builds
columns = {
  'Total' => ->(builds) {builds},
  'Pipeline' => ->(builds) {builds.select {|i| %w(staging test production).include?(i[:branch])}},
  'Branch' => ->(builds) {builds.reject {|i| %w(staging test production).include?(i[:branch])}}
}
options[:custom_columns].each do |branches|
  columns[branches.join(',')] = ->(builds) {builds.select{|i| branches.include?(i[:branch])}}
end
# Or only show one branch if we passed the branch option
unless options[:branch].nil?
  columns = {
      options[:branch] => ->(builds) {builds.select {|i| i[:branch] == options[:branch]}}
  }
end

# Compute map of stats for each date
stats_by_date = builds_by_date.hmap do |date, build_infos_for_date|
  [
    date,
    columns.hmap do |name, column|
      builds = column.call build_infos_for_date
      succeeded_builds = builds.select {|i| i[:succeeded]}.count
      failed_builds = builds.select {|i| i[:failed]}.count
      [
        name,
        {
          total_builds: succeeded_builds + failed_builds,
          failed_builds: failed_builds,
          failure_rate: Float(failed_builds) / (succeeded_builds + failed_builds)
        }
      ]
    end
  ]
end

# Print build stats
puts "Failure rates for builds #{build_range} by date (1.0 = 100% failures)"
if options[:output_format] == 'csv'
  puts format("%s#{',%s' * columns.size}", 'Date', *columns.keys)
  stats_by_date.each do |date, stats|
    puts format("%s#{',%.3f' * columns.size}", date, *stats.map {|_, v| v[:failure_rate].round(3)})
  end

elsif options[:output_format] == :plot

  #
  # Display a graph of failure rates over time
  #

  raise Exception.new('Must provide a --branch to plot') if options[:branch].nil?

  # Make sure weekends are included, and show up as zero
  dates = stats_by_date.keys.map{|d| DateTime.strptime("#{d} -8", '%Y-%m-%d %z')}
  ordered_stats = []
  (dates.min..dates.max).each do |date|
    if date.wday == 0 || date.wday == 6
      ordered_stats << {
          date: date,
          total_builds: 0,
          failed_builds: 0
      }
    else
      branch_stats = stats_by_date[date.strftime('%Y-%m-%d')][options[:branch]]
      ordered_stats << {
          date: date,
          total_builds: branch_stats[:total_builds],
          failed_builds: branch_stats[:failed_builds]
      }
    end
  end

  js_data = "[\n"
  js_data += "['Date', 'Failures', 'Successes'],\n"
  ordered_stats.each do |stats|
    # Represent date as a JS date, constructed with ms since the epoch
    js_build_time = "new Date(#{stats[:date].to_f * 1000})"
    js_failures = stats[:failed_builds]
    js_successes = stats[:total_builds] - stats[:failed_builds]

    js_data += "[#{js_build_time}, #{js_failures}, #{js_successes}],\n"
  end
  js_data += "]\n"

  title = "Circle CI #{options[:branch]} builds by outcome for #{dates.min.strftime('%Y-%m-%d')}..#{dates.max.strftime('%Y-%m-%d')} (builds #{build_range})"

  # Write out plot
  # https://developers.google.com/chart/interactive/docs/gallery/areachart
  FileUtils.mkdir_p OUTPUT_DIRECTORY
  path = "#{OUTPUT_DIRECTORY}/failure-rates.html"
  File.open(path, 'w') do |file|
    file.write <<-FILE
<html>
  <head>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script type="text/javascript">
      google.charts.load('current', {'packages':['corechart']});
      google.charts.setOnLoadCallback(drawChart);

      function drawChart() {
        var data = google.visualization.arrayToDataTable(#{js_data});

        var options = {
          title: '#{title}',
          hAxis: {title: 'Build date',  titleTextStyle: {color: '#333'}},
          colors: ['#C40000', '#7FB900'],
          isStacked: true
        };

        var chart = new google.visualization.SteppedAreaChart(document.getElementById('chart_div'));
        chart.draw(data, options);
      }
    </script>
  </head>
  <body>
    <div id="chart_div" style="width: 100%; height: 900px;"></div>
  </body>
</html>
    FILE
  end
  Launchy.open(path)

else

  puts format("%-10s#{' %16s' * columns.size}", 'Date', *columns.keys.map {|k| k[0, 14]})
  stats_by_date.each do |date, stats|
    puts format(
      "%-10s#{'  %7s = %5.3f' * columns.size}",
      date,
      *stats.map {|_, v| [format("%s/%s", v[:failed_builds], v[:total_builds]), v[:failure_rate].round(3)]}.flatten
    )
  end
end

exit(0)
